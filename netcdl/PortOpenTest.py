from ActiveTest import ActiveTest
import DefineMap

__author__ = 'Cody'

from scapy import all as s


class PortOpenTest(ActiveTest):
    def __init__(self, statement):
        self.port = statement.port
        self.protocol = statement.protocol
        self.host = str(DefineMap.lookup_host(statement.reachable.host))
        self.should_pass = statement.reachable.should == 'should'
        self.timeout = 3
        should_str = "should" if self.should_pass else "should not"
        self.display_str = "{0} {1} be reachable on {2} port {3}".format(self.host, should_str, self.protocol,
                                                                         self.port)
        super(PortOpenTest, self).__init__(statement)

    # Returns True for open, False for Closed or filtered

    def udp_scan(self):
        # TODO need to do retries?
        udp_scan_resp = s.sr1(s.IP(dst=self.host) / s.UDP(dport=self.port), timeout=self.timeout)

        if (str(type(udp_scan_resp)) == "<type 'NoneType'>"):
            # filtered
            return False
        elif (udp_scan_resp.haslayer(s.UDP)):
            return True
        elif (udp_scan_resp.haslayer(s.ICMP)):
            if (int(udp_scan_resp.getlayer(s.ICMP).type) == 3 and int(udp_scan_resp.getlayer(s.ICMP).code) == 3):
                return False
            elif (int(udp_scan_resp.getlayer(s.ICMP).type) == 3 and int(udp_scan_resp.getlayer(s.ICMP).code) in [1, 2, 9,
                                                                                                             10, 13]):
                return False

    # Returns True for open, False for Closed
    def tcp_scan(self):
        src_port = s.RandShort()
        tcp_connect_scan_resp = s.sr1(s.IP(dst=self.host) / s.TCP(sport=src_port, dport=self.port, flags="S"),
                                    timeout=self.timeout)
        if (str(type(tcp_connect_scan_resp)) == "<type 'NoneType'>"):
            return False
        elif (tcp_connect_scan_resp.haslayer(s.TCP)):
            if (tcp_connect_scan_resp.getlayer(s.TCP).flags == 0x12):
                # send TCP RST
                s.sr(s.IP(dst=self.host) / s.TCP(sport=src_port, dport=self.port, flags="AR"), timeout=self.timeout)
                return True
            elif (tcp_connect_scan_resp.getlayer(s.TCP).flags == 0x14):
                return False

    def run(self, q):
        try:
            open = self.tcp_scan() if self.protocol == 'TCP' else self.udp_scan()
            if open and self.should_pass or not open and not self.should_pass:
                self.success = True
            else:
                self.success = False
        except Exception as e:
            self.success = False

        return q.put(self.create_result())
